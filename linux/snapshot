#!/bin/bash

set -o pipefail

# constants
_24hrs=86400
_30days=2592000
_1year=$((365 * 24 * 60 * 60))

config_var(){
    CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}"
    CONF_FILE="${CONFIG}/snapshots/snapshots.conf"
    if [[ -f "${CONF_FILE}" ]]
    then
        cat "${CONF_FILE}"|awk -v var="$1" -F= '{if ($0 ~ var) print$2}'
    else
        echo "Could not find config file" 1>&2
        exit 1
    fi
}

mountvol() {
    if ! mount | grep -q "$1"
    then
        mount $1
    fi
}

fdate() {
    date +'%F-%T'
}

snapls() {
    SNAPPATH=$([[ -n "$2" ]] && echo "${2}" || echo "${LOCAL_SNAPSHOT_MOUNT}")
    cd "${SNAPPATH}"
    find . -maxdepth 1 -type d -maxdepth 1 \
        -name "${1}*" -printf '%f\n'
}

snapshot() {
    while IFS= read -r snapname
    do
        snapname=${snapname#@}
        if [ "root" == "${snapname}" ]
        then snaproot="/"
        else snaproot="/${snapname}"
        fi
        snapdest="${LOCAL_SNAPSHOT_MOUNT}"
        [[ ! -d "${snapdest}" ]] && mkdir "${snapdest}"
        btrfs subv snapshot -r \
            "${snaproot}" \
            "${snapdest}/${snapname}-$(fdate)"
    done
}

is_snapshot_in_24_hrs() {
    snapshotdate=$(echo "$1" | awk -F'-' '{print $2"-"$3"-"$4" "$5}')
    snapshotdate=$(date --date="$snapshotdate" +"%s")
    now=$(date +"%s")
    [[ $((now - snapshotdate)) -lt $_24hrs ]] || false && true
}

monthly_in_last_year() {
    # Todo - switch awk to param expansion
    while IFS= read -r snapshotname
    do
        snapshotdate=$(echo "$snapshotname" | awk -F'-' '{print $2"-"$3"-"$4" "$5}')
        snapshotdate=$(date --date="$snapshotdate" +"%s")
        now=$(date +"%s")
        month=$(echo "$snapshotname" | awk -F'-' '{print $3}')
        if [[ $((now - snapshotdate)) -lt $_1year  ]] &&
           [[ $((now - snapshotdate)) -gt $_30days ]]
        then
            if [[ -z $lastmonth ]] || [[ "$lastmonth" != "$month" ]]
            then
                echo "$snapshotname"
                lastmonth=$month
            elif [[ "$lastmonth" == "$month" ]]
            then
                continue
            fi
        fi
    done <<<$(snapls $1 $2)
}

daily_in_last_month() {
    # Todo - switch awk to param expansion
    while IFS= read -r snapshotname
    do
        snapshotdate=$(echo "$snapshotname" | awk -F'-' '{print $2"-"$3"-"$4" "$5}')
        snapshotdate=$(date --date="$snapshotdate" +"%s")
        now=$(date +"%s")
        day=$(echo "$snapshotname" | awk -F'-' '{print $4}')
        if [[ $((now - snapshotdate)) -lt $_30days ]] &&
           [[ $((now - snapshotdate)) -gt $_24hrs  ]]
        then
            if [[ -z $lastday ]] || [[ "$lastday" != "$day" ]]
            then
                echo "$snapshotname"
                lastday=$day
            elif [[ "$lastday" == "$day" ]]
            then
                continue
            fi

        fi
    done <<<$(snapls $1 $2)
}

hourly_in_last_day(){
    while IFS= read -r i
    do
        if is_snapshot_in_24_hrs $i 
        then
            echo "$i"
        fi
    done <<<"$(snapls $1 $2)"
}

get_keep_snapshots() {
    monthly_in_last_year "$@"
    daily_in_last_month "$@"
    hourly_in_last_day "$@"
}

invert_list() {
    NOTLIST="$1"
    SNAPVOLUME="$2"
    while IFS= read -r snapshot
    do
        in_list=no
        while IFS= read -r keepsnap
        do
            [[ "$in_list" == "yes" ]] && continue
            if [[ "$keepsnap" == "$snapshot" ]]
            then
                in_list=yes
            fi
        done <<<"$NOTLIST"
        [[ "$in_list" == "no" ]] && echo "$snapshot"
    done <<<"$(snapls "$SNAPVOLUME" $3)"
}

remove_snapshots() {
    ROOT=$1
    while IFS= read -r snapshot
    do
        echo "Removing ${ROOT}/$snapshot"
        btrfs subvol delete "${ROOT}/$snapshot"
    done
}

prune() {
    # keeps last 24 hrs of snapshots
    # keeps daily backups for the past month
    # keeps weekly backups until disk threshold percentage is reached

    # step 1. Build a list of backups to keep
    # step 2. Invert the list
    # step 3. delete snapshots in the list
    # step 4. calculate space needed to get back to meet threshold
    # step 5. build list of snapshots from oldest to newest with their exclusive space used
    # step 6. build list of number of snapshots needed to delete to meet threshold
    # step 7. delete list of snapshots
    # step 6. delete oldest to
    ROOT="${1}"
    while IFS= read -r vol
    do
        vol="${vol#@}"
        snaps_to_keep=$(get_keep_snapshots "$vol" $ROOT)
        prune_list="$(invert_list "$snaps_to_keep" "$vol" "$ROOT")"
        num_to_prune=$(num_of_snaps "$prune_list")
        [ "$num_to_prune" -eq 0 ] && continue
        echo "keep $(num_of_snaps $snaps_to_keep) $vol snaps on $ROOT"
        echo "prune $num_to_prune $vol snaps on $ROOT"
        echo "$prune_list" | remove_snapshots "$ROOT"
    done
}

num_of_snaps(){
    echo "$1" | grep -ce '\w\+'
}

only_in_a(){
    IFS=$'\n'
    a=$1
    b=$2
    for i in $a; {
        in_b=false
        for j in $b; {
            if [[ "$i" == "$j" ]]; then
                #echo "Ahah! $i is equal to $j"
                in_b=true
            fi
        }
        if ! $in_b; then echo $i; fi
    }
}

a_and_b(){
    IFS=$'\n'
    a=$1
    b=$2
    for i in $a; {
        in_b=false
        for j in $b; {
            if [[ "$i" == "$j" ]]; then
                #echo "Ahah! $i is equal to $j"
                in_b=true
            fi
        }
        if $in_b; then echo $i; fi
    }
}

send(){
    IFS=$'\n'
    list_to_backup=$1
    possible_parents=$2
    parent=$(echo "$possible_parents"|tail -1)
    for i in $list_to_backup; do
        if [[ -n $parent ]]
        then
            echo "backup $i with parent $parent"
            btrfs send -p "${LOCAL_SNAPSHOT_MOUNT}/$parent" \
                "${LOCAL_SNAPSHOT_MOUNT}/$i" |
                btrfs receive "${EXTERN_SNAPSHOT_MOUNT}"
            if [ $? != 0 ]; then
                echo "An error occurred. Halting."
                exit 1
            fi
        else
            echo "full backup $i"
            btrfs send "${LOCAL_SNAPSHOT_MOUNT}/$i" |
                btrfs receive "${EXTERN_SNAPSHOT_MOUNT}"
            if [ $? != 0 ]; then
                echo "An error occurred. Halting."
                exit 1
            fi
        fi
        parent=$i
    done
}

prune_but_keep_some(){
    IFS=$'\n'
    list=$1
    new_list=$(echo "$list"|head -n -2)
    for i in $new_list; do
        echo "removing $i"
        btrfs subvol delete "${LOCAL_SNAPSHOT_MOUNT}/$i"
        if [ $? != 0 ]; then
            echo "An error occurred. Halting"
            exit 1
        fi
    done
}

backup_snapshots(){
    # 1. Check what the last snapshot on the extern is
    # 2. Check we also have that locally
    # 3. Get a list of the next load of snapshots in
    #    sequence is.
    # 4. Foreach one, send it across and once it is send
    #    delete it locally except the last one.
    while IFS= read -r vol
    do
        vol="${vol#@}"
        all_extern_snaps=$(snapls "${vol}" "${EXTERN_SNAPSHOT_MOUNT}")
        all_intern_snaps=$(snapls "${vol}" "${LOCAL_SNAPSHOT_MOUNT}")
        num_of_extern_snaps=$(num_of_snaps "$all_extern_snaps")
        num_of_intern_snaps=$(num_of_snaps "$all_intern_snaps")
        echo "there are $num_of_intern_snaps snapshots of $vol"
        [ "$num_of_intern_snaps" == 0 ] && 
            echo "skipping $vol" && continue
        # get a list of snapshots that don't exist on intern yet
        # get a list of snapshots that exist on both
        only_intern=$(only_in_a "$all_intern_snaps" "$all_extern_snaps")
        num_only_intern=$(num_of_snaps "$only_intern")
        [ "$num_only_intern" == 0 ] &&
            echo "none to send for $vol" && continue
        intern_and_extern=$(a_and_b "$all_intern_snaps" "$all_extern_snaps")
        echo "need to send over $num_only_intern"
        send "$only_intern" "$intern_and_extern" || exit 1
        prune_but_keep_some "$all_intern_snaps" || exit 1
    done
}

attempt_extern_backup(){
    if [[ -d "${EXTERN_SNAPSHOT_MOUNT}" ]]
    then
        echo "attempting to backup to external disk"
        echo $SUBVOLUMES | backup_snapshots
        echo $SUBVOLUMES | prune "${EXTERN_SNAPSHOT_MOUNT}"
    else
        echo "${EXTERN_SNAPSHOT_MOUNT} not mounted"
    fi
}

# get volumes to snapshot
VOLUMES_ROOT_MOUNT=$(config_var "BtrfsRoot") || exit 1
LOCAL_SNAPSHOT_MOUNT=$(config_var "LocalSnapshots") || exit 1
EXTERN_SNAPSHOT_MOUNT=$(config_var "RemoteSnapshots") || exit 1 
SUBVOLUMES=$(ls "${VOLUMES_ROOT_MOUNT}" | grep -v "${LOCAL_SNAPSHOT_MOUNT##*/}")


if [[ "$1" == "-b" ]]
then
    attempt_extern_backup
else
    echo $SUBVOLUMES | snapshot
    echo $SUBVOLUMES | prune "${LOCAL_SNAPSHOT_MOUNT}"
    attempt_extern_backup
fi
