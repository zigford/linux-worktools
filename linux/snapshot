#!/bin/bash

set -o pipefail

# constants
_24hrs=86400
_30days=2592000
_1year=$((365 * 24 * 60 * 60))
CONF_FILE="/etc/snapshots.conf"

config_var(){
    # CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}"
    # CONF_FILE="${CONFIG}/snapshots/snapshots.conf"
    CONF_FILE="/etc/snapshots.conf"
    if [[ -f "${CONF_FILE}" ]]
    then
        cat "${CONF_FILE}"|awk -v var="$1" -F= '{if ($0 ~ var) print$2}'
    else
        echo "Could not find config file" 1>&2
        exit 1
    fi
}

mountvol() {
    if ! mount | grep -q "$1"
    then
        mount $1
    fi
}

fdate() {
    date +'%F-%T'
}

snapls() {
    cd "${2}"
    find . -maxdepth 1 -type d \
        -name "${1}*" -printf '%f\n'
}

snapshot() {
    snapname=$1
    snaproot=$2
    snapdest=$3
    [[ ! -d "${snapdest}" ]] && mkdir "${snapdest}"
    btrfs subv snapshot -r \
        "${snaproot}" \
        "${snapdest}/${snapname}-$(fdate)"
}

is_snapshot_in_24_hrs() {
    snapshotdate=$(echo "$1" | awk -F'-' '{print $2"-"$3"-"$4" "$5}')
    snapshotdate=$(date --date="$snapshotdate" +"%s")
    now=$(date +"%s")
    [[ $((now - snapshotdate)) -lt $_24hrs ]] || false && true
}

monthly_in_last_year() {
    # Todo - switch awk to param expansion
    while IFS= read -r snapshotname
    do
        snapshotdate=$(echo "$snapshotname" | awk -F'-' '{print $2"-"$3"-"$4" "$5}')
        snapshotdate=$(date --date="$snapshotdate" +"%s")
        now=$(date +"%s")
        month=$(echo "$snapshotname" | awk -F'-' '{print $3}')
        if [[ $((now - snapshotdate)) -lt $_1year  ]] &&
           [[ $((now - snapshotdate)) -gt $_30days ]]
        then
            if [[ -z $lastmonth ]] || [[ "$lastmonth" != "$month" ]]
            then
                echo "$snapshotname"
                lastmonth=$month
            elif [[ "$lastmonth" == "$month" ]]
            then
                continue
            fi
        fi
    done <<<$(snapls $1 $2)
}

daily_in_last_month() {
    # Todo - switch awk to param expansion
    while IFS= read -r snapshotname
    do
        snapshotdate=$(echo "$snapshotname" | awk -F'-' '{print $2"-"$3"-"$4" "$5}')
        snapshotdate=$(date --date="$snapshotdate" +"%s")
        now=$(date +"%s")
        day=$(echo "$snapshotname" | awk -F'-' '{print $4}')
        if [[ $((now - snapshotdate)) -lt $_30days ]] &&
           [[ $((now - snapshotdate)) -gt $_24hrs  ]]
        then
            if [[ -z $lastday ]] || [[ "$lastday" != "$day" ]]
            then
                echo "$snapshotname"
                lastday=$day
            elif [[ "$lastday" == "$day" ]]
            then
                continue
            fi

        fi
    done <<<$(snapls $1 $2)
}

hourly_in_last_day(){
    while IFS= read -r i
    do
        if is_snapshot_in_24_hrs $i 
        then
            echo "$i"
        fi
    done <<<"$(snapls $1 $2)"
}

get_keep_snapshots() {
    monthly_in_last_year "$@"
    daily_in_last_month "$@"
    hourly_in_last_day "$@"
}

invert_list() {
    NOTLIST="$1"
    SNAPVOLUME="$2"
    while IFS= read -r snapshot
    do
        in_list=no
        while IFS= read -r keepsnap
        do
            [[ "$in_list" == "yes" ]] && continue
            if [[ "$keepsnap" == "$snapshot" ]]
            then
                in_list=yes
            fi
        done <<<"$NOTLIST"
        [[ "$in_list" == "no" ]] && echo "$snapshot"
    done <<<"$(snapls "$SNAPVOLUME" $3)"
}

remove_snapshots() {
    ROOT=$1
    while IFS= read -r snapshot
    do
        #echo "Removing ${ROOT}/$snapshot"
        btrfs subvol delete "${ROOT}/$snapshot"
    done
}

prune() {
    # keeps last 24 hrs of snapshots
    # keeps daily backups for the past month
    # keeps weekly backups until disk threshold percentage is reached

    # step 1. Build a list of backups to keep
    # step 2. Invert the list
    # step 3. delete snapshots in the list
    # step 4. calculate space needed to get back to meet threshold
    # step 5. build list of snapshots from oldest to newest with their exclusive space used
    # step 6. build list of number of snapshots needed to delete to meet threshold
    # step 7. delete list of snapshots
    # step 6. delete oldest to
    vol=$1
    ROOT=$2
    snaps_to_keep=$(get_keep_snapshots "$vol" $ROOT)
    prune_list="$(invert_list "$snaps_to_keep" "$vol" "$ROOT")"
    num_to_prune=$(num_of_snaps "$prune_list")
    [ "$num_to_prune" -eq 0 ] && return
    echo "keep $(num_of_snaps "$snaps_to_keep") $vol snaps on $ROOT"
    echo "prune $num_to_prune $vol snaps on $ROOT"
    echo "$prune_list" | remove_snapshots "$ROOT"
}

num_of_snaps(){
    echo "$1" | grep -ce '\w\+'
}

only_in_a(){
    IFS=$'\n'
    a=$1
    b=$2
    for i in $a; {
        in_b=false
        for j in $b; {
            if [[ "$i" == "$j" ]]; then
                #echo "Ahah! $i is equal to $j"
                in_b=true
            fi
        }
        if ! $in_b; then echo $i; fi
    }
}

a_and_b(){
    IFS=$'\n'
    a=$1
    b=$2
    for i in $a; {
        in_b=false
        for j in $b; {
            if [[ "$i" == "$j" ]]; then
                #echo "Ahah! $i is equal to $j"
                in_b=true
            fi
        }
        if $in_b; then echo $i; fi
    }
}

send(){
    IFS=$'\n'
    list_to_backup=$1
    possible_parents=$2
    parent=$(echo "$possible_parents"|tail -1)
    for i in $list_to_backup; do
        if [[ -n $parent ]]
        then
            echo "backup $i with parent $parent"
            btrfs send -p "${LOCAL_SNAPSHOT_MOUNT}/$parent" \
                "${LOCAL_SNAPSHOT_MOUNT}/$i" |
                btrfs receive "${EXTERN_SNAPSHOT_MOUNT}"
            if [ $? != 0 ]; then
                echo "An error occurred. Halting."
                exit 1
            fi
        else
            echo "full backup $i"
            btrfs send "${LOCAL_SNAPSHOT_MOUNT}/$i" |
                btrfs receive "${EXTERN_SNAPSHOT_MOUNT}"
            if [ $? != 0 ]; then
                echo "An error occurred. Halting."
                exit 1
            fi
        fi
        parent=$i
    done
}

prune_but_keep_some(){
    IFS=$'\n'
    list=$1
    new_list=$(echo "$list"|head -n -2)
    for i in $new_list; do
        echo "removing $i"
        btrfs subvol delete "${LOCAL_SNAPSHOT_MOUNT}/$i"
        if [ $? != 0 ]; then
            echo "An error occurred. Halting"
            exit 1
        fi
    done
}

backup_snapshots(){
    # 1. Check what the last snapshot on the extern is
    # 2. Check we also have that locally
    # 3. Get a list of the next load of snapshots in
    #    sequence is.
    # 4. Foreach one, send it across and once it is send
    #    delete it locally except the last one.
    while IFS= read -r vol
    do
        vol="${vol#@}"
        all_extern_snaps=$(snapls "${vol}" "${EXTERN_SNAPSHOT_MOUNT}")
        all_intern_snaps=$(snapls "${vol}" "${LOCAL_SNAPSHOT_MOUNT}")
        num_of_extern_snaps=$(num_of_snaps "$all_extern_snaps")
        num_of_intern_snaps=$(num_of_snaps "$all_intern_snaps")
        echo "there are $num_of_intern_snaps snapshots of $vol"
        [ "$num_of_intern_snaps" == 0 ] && 
            echo "skipping $vol" && continue
        # get a list of snapshots that don't exist on intern yet
        # get a list of snapshots that exist on both
        only_intern=$(only_in_a "$all_intern_snaps" "$all_extern_snaps")
        num_only_intern=$(num_of_snaps "$only_intern")
        [ "$num_only_intern" == 0 ] &&
            echo "none to send for $vol" && continue
        intern_and_extern=$(a_and_b "$all_intern_snaps" "$all_extern_snaps")
        echo "need to send over $num_only_intern"
        send "$only_intern" "$intern_and_extern" || exit 1
        prune_but_keep_some "$all_intern_snaps" || exit 1
    done
}

attempt_extern_backup(){
    if [[ -d "${EXTERN_SNAPSHOT_MOUNT}" ]]
    then
        echo "attempting to backup to external disk"
        echo "$SUBVOLUMES" | backup_snapshots
        echo "$SUBVOLUMES" | prune "${EXTERN_SNAPSHOT_MOUNT}"
    else
        echo "${EXTERN_SNAPSHOT_MOUNT} not mounted"
    fi
}

test_running_send(){
    pgrep() {
        if ps aux | grep -v grep | grep -q "$1"
        then
            true
        else
            false
        fi
    }
    if pgrep "btrfs send" || pgrep "btrfs receive"
    then
        true
    else
        false
    fi
}

get_config() {
    case "$1" in
        "count")
            awk '/\[.*\]/ {a=a+1}END{print a}' $CONF_FILE
            ;;
        "list")
            awk -F'\\[|\\]' '/\[.*\]/ {print $2}' $CONF_FILE
            ;;
        *)
            [[ -z "$2" ]] &&
                echo "specify config and setting" && exit 1
            awk -F"=" -v s="$1" -v c="$2" '{
                if ($0 ~ /\[.*\]/) { 
                    if ($0 ~ c) {
                        in_s = 1
                    } else {
                        in_s = 0
                    }
                } else {
                    if (in_s) {
                        if ($0 ~ s) {
                            print $2
                        }
                }
                }
            }' $CONF_FILE
            ;;
    esac

}

#get_config count
#get_config BtrfsRoot root
#get_config list

# get volumes to snapshot
for config in $(get_config list); do
    echo "Snapshotting $config"
    VOLUME_ROOT_MOUNT=$(get_config BtrfsRoot $config) || exit 1
    LOCAL_SNAPSHOT_MOUNT=$(get_config LocalSnapshots $config) || exit 1
    EXTERN_SNAPSHOT_MOUNT=$(get_config RemoteSnapshots $config) || exit 1 
    SUBVOLUME=$(get_config SubvolumeRoot $config) || exit 1
    if [[ "$1" == "-b" ]]
    then
        if [[ test_running_send ]]
        then
            echo "Backup already in progress"
        else
            attempt_extern_backup
        fi
    else
        snapshot $config $SUBVOLUME "${LOCAL_SNAPSHOT_MOUNT}" 
        prune $config "${LOCAL_SNAPSHOT_MOUNT}"
#        echo "$SUBVOLUMES" | prune "${LOCAL_SNAPSHOT_MOUNT}"
    #    if [[ test_running_send ]]
    #    then
    #        echo "Backup already in progress"
    #    else
    #        attempt_extern_backup
    #    fi
    fi
done

