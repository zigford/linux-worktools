#!/bin/bash

set -o pipefail

# constants
_24hrs=86400
_30days=2592000
_1year=$((365 * 24 * 60 * 60))
CONF_FILE="/etc/snapshots.conf"

mountvol() {
    if ! mount | grep -q "$1"
    then
        mount $1
    fi
}

fdate() {
    date +'%F-%T'
}

snapls() {
    cd "${2}"
    find . -maxdepth 1 -type d \
        -name "${1}*" -printf '%f\n'
}

snapshot() {
    [[ ! -d "${LOCAL_SNAPSHOT_MOUNT}" ]] && mkdir "${LOCAL_SNAPSHOT_MOUNT}"
    if [[ -z "$noop" ]]
    then
        btrfs subv snapshot -r \
            "${SUBVOLUME}" \
            "${LOCAL_SNAPSHOT_MOUNT}/${config}-$(fdate)"
    fi
}

is_snapshot_in_24_hrs() {
    snapshotdate=$(echo "$1" | awk -F'-' '{print $2"-"$3"-"$4" "$5}')
    snapshotdate=$(date --date="$snapshotdate" +"%s")
    now=$(date +"%s")
    [[ $((now - snapshotdate)) -lt $_24hrs ]] || false && true
}

monthly_in_last_year() {
    # Todo - switch awk to param expansion
    while IFS= read -r snapshotname
    do
        snapshotdate=$(echo "$snapshotname" | awk -F'-' '{print $2"-"$3"-"$4" "$5}')
        snapshotdate=$(date --date="$snapshotdate" +"%s")
        now=$(date +"%s")
        month=$(echo "$snapshotname" | awk -F'-' '{print $3}')
        if [[ $((now - snapshotdate)) -lt $_1year  ]] &&
           [[ $((now - snapshotdate)) -gt $_30days ]]
        then
            if [[ -z $lastmonth ]] || [[ "$lastmonth" != "$month" ]]
            then
                echo "$snapshotname"
                lastmonth=$month
            elif [[ "$lastmonth" == "$month" ]]
            then
                continue
            fi
        fi
    done <<<$(snapls $1 $2)
}

daily_in_last_month() {
    # Todo - switch awk to param expansion
    while IFS= read -r snapshotname
    do
        snapshotdate=$(echo "$snapshotname" | awk -F'-' '{print $2"-"$3"-"$4" "$5}')
        snapshotdate=$(date --date="$snapshotdate" +"%s")
        now=$(date +"%s")
        day=$(echo "$snapshotname" | awk -F'-' '{print $4}')
        if [[ $((now - snapshotdate)) -lt $_30days ]] &&
           [[ $((now - snapshotdate)) -gt $_24hrs  ]]
        then
            if [[ -z $lastday ]] || [[ "$lastday" != "$day" ]]
            then
                echo "$snapshotname"
                lastday=$day
            elif [[ "$lastday" == "$day" ]]
            then
                continue
            fi

        fi
    done <<<$(snapls $1 $2)
}

hourly_in_last_day(){
    while IFS= read -r i
    do
        if is_snapshot_in_24_hrs $i 
        then
            echo "$i"
        fi
    done <<<"$(snapls $1 $2)"
}

get_keep_snapshots() {
    monthly_in_last_year "$@"
    daily_in_last_month "$@"
    hourly_in_last_day "$@"
}

invert_list() {
    NOTLIST="$1"
    SNAPVOLUME="$2"
    while IFS= read -r snapshot
    do
        in_list=no
        while IFS= read -r keepsnap
        do
            [[ "$in_list" == "yes" ]] && continue
            if [[ "$keepsnap" == "$snapshot" ]]
            then
                in_list=yes
            fi
        done <<<"$NOTLIST"
        [[ "$in_list" == "no" ]] && echo "$snapshot"
    done <<<"$(snapls "$SNAPVOLUME" $3)"
}

remove_snapshots() {
    ROOT=$1
    while IFS= read -r snapshot
    do
        echo "Removing ${ROOT}/$snapshot"
        if [[ -z "$noop" ]]
        then
            btrfs subvol delete "${ROOT}/$snapshot"
        fi
    done
}

prune() {
    # keeps last 24 hrs of snapshots
    # keeps daily backups for the past month
    # keeps weekly backups until disk threshold percentage is reached

    # step 1. Build a list of backups to keep
    # step 2. Invert the list
    # step 3. delete snapshots in the list
    # step 4. calculate space needed to get back to meet threshold
    # step 5. build list of snapshots from oldest to newest with their exclusive space used
    # step 6. build list of number of snapshots needed to delete to meet threshold
    # step 7. delete list of snapshots
    # step 6. delete oldest to
    snaps_to_keep=$(get_keep_snapshots "$config" $LOCAL_SNAPSHOT_MOUNT)
    prune_list="$(invert_list "$snaps_to_keep" "$config" "$LOCAL_SNAPSHOT_MOUNT")"
    num_to_prune=$(num_of_snaps "$prune_list")
    [ "$num_to_prune" -eq 0 ] && return
    echo "keep $(num_of_snaps "$snaps_to_keep") $config snaps on $LOCAL_SNAPSHOT_MOUNT"
    echo "prune $num_to_prune $config snaps on $LOCAL_SNAPSHOT_MOUNT"
    echo "$prune_list" | remove_snapshots "$LOCAL_SNAPSHOT_MOUNT"
}

num_of_snaps(){
    echo "$1" | grep -ce '\w\+'
}

only_in_a(){
    IFS=$'\n'
    a=$1
    b=$2
    for i in $a; {
        in_b=false
        for j in $b; {
            if [[ "$i" == "$j" ]]; then
                #echo "Ahah! $i is equal to $j"
                in_b=true
            fi
        }
        if ! $in_b; then echo $i; fi
    }
}

a_and_b(){
    IFS=$'\n'
    a=$1
    b=$2
    for i in $a; {
        in_b=false
        for j in $b; {
            if [[ "$i" == "$j" ]]; then
                #echo "Ahah! $i is equal to $j"
                in_b=true
            fi
        }
        if $in_b; then echo $i; fi
    }
}

send(){
    IFS=$'\n'
    list_to_backup=$1
    possible_parents=$2
    parent=$(echo "$possible_parents"|tail -1)
    for i in $list_to_backup; do
        if [[ -n $parent ]]
        then
            echo "backup $i with parent $parent"
            if [[ -z "$noop" ]]
            then
                btrfs send -p "${LOCAL_SNAPSHOT_MOUNT}/$parent" \
                    "${LOCAL_SNAPSHOT_MOUNT}/$i" |
                    btrfs receive "${EXTERN_SNAPSHOT_MOUNT}"
                if [ $? != 0 ]; then
                    echo "An error occurred. Halting."
                    exit 1
                fi
            fi
        else
            echo "full backup $i"
            if [[ -z "$noop" ]]
            then
                btrfs send "${LOCAL_SNAPSHOT_MOUNT}/$i" |
                    btrfs receive "${EXTERN_SNAPSHOT_MOUNT}"
                if [ $? != 0 ]; then
                    echo "An error occurred. Halting."
                    exit 1
                fi
            fi
        fi
        parent=$i
    done
}

prune_but_keep_some(){
    IFS=$'\n'
    list=$1
    new_list=$(echo "$list"|head -n -2)
    for i in $new_list; do
        echo "removing $i"
        if [[ -z "$noop" ]]
        then
            btrfs subvol delete "${LOCAL_SNAPSHOT_MOUNT}/$i"
            if [ $? != 0 ]; then
                echo "An error occurred. Halting"
                exit 1
            fi
        fi
    done
}

backup_snapshots(){
    # 1. Check what the last snapshot on the extern is
    # 2. Check we also have that locally
    # 3. Get a list of the next load of snapshots in
    #    sequence is.
    # 4. Foreach one, send it across and once it is send
    #    delete it locally except the last one.
    all_extern_snaps=$(snapls "${config}" "${EXTERN_SNAPSHOT_MOUNT}")
    all_intern_snaps=$(snapls "${config}" "${LOCAL_SNAPSHOT_MOUNT}")
    num_of_extern_snaps=$(num_of_snaps "$all_extern_snaps")
    num_of_intern_snaps=$(num_of_snaps "$all_intern_snaps")
    echo "there are $num_of_intern_snaps snapshots of $config"
    [ "$num_of_intern_snaps" == 0 ] && 
        echo "skipping $config" && continue
    # get a list of snapshots that don't exist on intern yet
    # get a list of snapshots that exist on both
    only_intern=$(only_in_a "$all_intern_snaps" "$all_extern_snaps")
    num_only_intern=$(num_of_snaps "$only_intern")
    [ "$num_only_intern" == 0 ] &&
        echo "none to send for $config" && continue
    intern_and_extern=$(a_and_b "$all_intern_snaps" "$all_extern_snaps")
    echo "need to send over $num_only_intern"
    send "$only_intern" "$intern_and_extern" || exit 1
    prune_but_keep_some "$all_intern_snaps" || exit 1
}

attempt_extern_backup() {
    [[ "$backup" == "false" ]] && return 0
    if [[ -d "${EXTERN_SNAPSHOT_MOUNT}" ]]
    then
        if test_running_send
        then
            echo "Backup already in progress"
        else
            echo "attempting to backup to external disk"
            # backup_snapshots "$SUBVOLUME" 
            backup_snapshots $config
            #prune "${EXTERN_SNAPSHOT_MOUNT}"
        fi
    else
        echo "${EXTERN_SNAPSHOT_MOUNT} not mounted"
    fi
}

test_running_send(){
    pgrep() {
        if ps aux | grep -v grep | grep -q "$1"
        then
            true
        else
            false
        fi
    }
    if pgrep "btrfs send" || pgrep "btrfs receive"
    then
        true
    else
        false
    fi
}

get_config() {
    case "$1" in
        "count")
            awk '/\[.*\]/ {a=a+1}END{print a}' $CONF_FILE
            ;;
        "list")
            awk -F'\\[|\\]' '/\[.*\]/ {print $2}' $CONF_FILE
            ;;
        *)
            [[ -z "$2" ]] &&
                echo "specify config and setting" && exit 1
            awk -F"=" -v s="$1" -v c="$2" '{
                if ($0 ~ /\[.*\]/) { 
                    if ($0 ~ c) {
                        in_s = 1
                    } else {
                        in_s = 0
                    }
                } else {
                    if (in_s) {
                        if ($0 ~ s) {
                            print $2
                        }
                }
                }
            }' $CONF_FILE
            ;;
    esac

}

usage() {
    echo -e "Usage: $0 [OPTION]...\n"
    echo "-b, --backup-only         backup snapshots"
    echo "-d, --dont-backup         take snapshots only"
    echo "-n, --dry-run             output what would be done"
}

while test $# -gt 0
do
    case "$1" in
        -b|--backup-only)   backup="true";shift;;
        -n|--dry-run)       noop="true";shift;;
        -d|--dont-backup)   backup="false";shift;;
        -h|--help)          usage;exit 0;;
        *)                  break;;
    esac
done

for config in $(get_config list); do
    echo "Snapshotting $config"
    LOCAL_SNAPSHOT_MOUNT=$(get_config LocalSnapshots $config) || exit 1
    EXTERN_SNAPSHOT_MOUNT=$(get_config RemoteSnapshots $config) || exit 1 
    SUBVOLUME=$(get_config SubvolumeRoot $config) || exit 1
    if [[ "$backup" == "true" ]]
    then
        attempt_extern_backup
    else
        snapshot
        prune
        attempt_extern_backup
    fi
done

